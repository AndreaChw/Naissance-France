##############################################################
# IMPORTATION, RENOMMAGE ET PRÉPARATION DES DONNÉES
##############################################################

library(readxl)
library(dplyr)
library(tidyr)
library(writexl)

# Étape 1 : Charger les données et renommer les colonnes
data <- read_excel("//Users/mehdifehri/Desktop/R/Données/Data R Ajustée.xlsx") %>%
  rename_with(~ gsub("-", "_", .), everything())  # Remplace les traits d'union par des underscores

# Identifier les colonnes numériques (à l'exception de 'Annee')
numeric_cols <- setdiff(colnames(data), "Annee")


##############################################################
# INTERPOLATION TRIMESTRIELLE
##############################################################

# Étape 2 : Interpolation trimestrielle (inclut 'fec')
data_interpolated <- data %>%
  complete(Annee = seq(min(Annee), max(Annee), by = 0.25)) %>%
  mutate(across(all_of(numeric_cols),
                ~ approx(Annee[!is.na(.)], .[!is.na(.)], xout = Annee)$y))


##############################################################
# DÉCALAGE TEMPOREL (LAG) DES VARIABLES EXPLICATIVES
##############################################################

# Étape 3 : Décalage temporel des variables (exclure 'fec')
data_lagged <- data_interpolated %>%
  arrange(Annee) %>%
  mutate(across(setdiff(numeric_cols, "fec"), ~ lag(., n = 4), .names = "lag_{col}"))

# Supprimer les lignes avec NA générés par le lag
data_clean <- data_lagged %>%
  drop_na(starts_with("lag_"))

# Étape 4 : Identifier les variables explicatives laggées
variables_explicatives_lag <- colnames(data_clean)[grepl("lag_", colnames(data_clean))]


##############################################################
# DÉFINITION DES TRANSFORMATIONS ET CALCUL DU R² AJUSTÉ
##############################################################

# Étape 5 : Appliquer les transformations et calculer les R² ajustés
# Créer un tableau pour stocker les résultats
results <- data.frame(
  Variable = character(),
  Transformation = character(),
  Adjusted_R2 = numeric(),
  Improvement = numeric(),
  stringsAsFactors = FALSE
)

# Définir les transformations possibles
transformations <- list(
  "None"    = function(x) x,
  "Log"     = function(x) ifelse(x > 0, log(x + 1), NA),
  "Sqrt"    = function(x) ifelse(x >= 0, sqrt(x), NA),
  "Quad"    = function(x) x^2,
  "Inverse" = function(x) ifelse(x != 0, 1 / (x + 1), NA)
)

# Fonction pour calculer le R² ajusté
get_adj_r2 <- function(formula, data) {
  model <- lm(formula, data = data)
  summary(model)$adj.r.squared
}


##############################################################
# TEST DES TRANSFORMATIONS POUR CHAQUE VARIABLE EXPLICATIVE LAGGÉE
##############################################################

for (var in variables_explicatives_lag) {
  # R² ajusté de base (sans transformation)
  base_r2 <- get_adj_r2(as.formula(paste("fec ~", var)), data_clean)
  
  # Tester chaque transformation
  for (trans_name in names(transformations)) {
    trans_func <- transformations[[trans_name]]
    transformed_var <- trans_func(data_clean[[var]])
    
    # Vérifier la présence de NA suite à la transformation
    if (anyNA(transformed_var)) {
      adj_r2 <- NA
    } else {
      data_clean$temp_var <- transformed_var
      adj_r2 <- get_adj_r2(as.formula("fec ~ temp_var"), data_clean)
    }
    
    # Ajouter les résultats au tableau
    results <- rbind(
      results,
      data.frame(
        Variable = var,
        Transformation = trans_name,
        Adjusted_R2 = adj_r2,
        Improvement = adj_r2 - base_r2,
        stringsAsFactors = FALSE
      )
    )
  }
}


##############################################################
# SÉLECTION DE LA MEILLEURE TRANSFORMATION POUR CHAQUE VARIABLE
##############################################################

# Étape 6 : Identifier la meilleure transformation
best_transformations <- results %>%
  group_by(Variable) %>%
  filter(Adjusted_R2 == max(Adjusted_R2, na.rm = TRUE)) %>%
  mutate(Keep_Transformation = if_else(Improvement > 0.05 & Transformation != "None", "Yes", "No")) %>%
  arrange(desc(Improvement))


##############################################################
# APPLICATION DES TRANSFORMATIONS RETENUES
##############################################################

# Étape 7 : Appliquer les transformations retenues et ajouter les variables transformées
final_dataframe <- data_clean

for (i in 1:nrow(best_transformations)) {
  var  <- best_transformations$Variable[i]
  trans <- best_transformations$Transformation[i]
  
  # Appliquer la transformation uniquement si "Yes"
  if (trans != "None" && best_transformations$Keep_Transformation[i] == "Yes") {
    transformed_var <- transformations[[trans]](data_clean[[var]])
    new_name <- paste0(var, "_", tolower(trans))
    final_dataframe[[new_name]] <- transformed_var
  }
}


##############################################################
# SAUVEGARDE DES RÉSULTATS
##############################################################

# Étape 8 : Sauvegarder les résultats sur les transformations et le DataFrame final
write_xlsx(best_transformations, "//Users/mehdifehri/Desktop/R/Données/Best_Transformations.xlsx")
write_xlsx(final_dataframe, "//Users/mehdifehri/Desktop/R/Données/Final_Data_Transformed.xlsx")


##############################################################
# CRÉATION DU DATAFRAME FINAL AVEC LES VAR. LAGGÉES ET LA VAR. DÉPENDANTE
##############################################################

# Étape 9 : Préparer le DataFrame final (Annee, fec, lag_)
final_dataframe_lagged <- final_dataframe %>%
  select(Annee, fec, starts_with("lag_"))

# Sauvegarde du DataFrame final laggé
write_xlsx(final_dataframe_lagged, "//Users/mehdifehri/Desktop/R/Données/Final_Data_Lagged.xlsx")

##############################################################
# DÉTECTION DES OUTLIERS ET VISUALISATION DES RÉSIDUS STANDARDISÉS
##############################################################

library(dplyr)
library(readxl)
library(writexl)
library(ggplot2)

# Étape 1 : Charger le DataFrame final laggé
final_dataframe_lagged <- read_excel("//Users/mehdifehri/Desktop/R/Données/Final_Data_Lagged.xlsx")

# Étape 2 : Ajuster un modèle linéaire
# Variable dépendante : "fec"
# Variables explicatives : toutes les colonnes sauf "fec" et "Annee"
model <- lm(fec ~ ., data = final_dataframe_lagged)

# Étape 3 : Calculer les résidus standardisés
standardized_residuals <- rstandard(model)

# Étape 4 : Créer un DataFrame avec les résidus standardisés et un index
residuals_df <- final_dataframe_lagged %>%
  mutate(
    Index = row_number(),
    Std_Resid = standardized_residuals
  )

# Étape 5 : Définir un seuil pour la détection des outliers
# Ici, on considère comme outlier toute observation avec |résidu| > 2
threshold <- 2

# Étape 6 : Identifier les outliers
outliers_df <- residuals_df %>%
  filter(abs(Std_Resid) > threshold)

# Étape 7 : Visualisation des résidus standardisés
plot_residus <- ggplot(residuals_df, aes(x = Index, y = Std_Resid)) +
  geom_point() +
  geom_hline(yintercept = c(-threshold, threshold), color = "red", linetype = "dashed") +
  labs(
    title = "Résidus standardisés du modèle linéaire",
    x = "Index de l'observation",
    y = "Résidu standardisé"
  ) +
  theme_minimal()

# Afficher le graphique
print(plot_residus)

# Étape 8 : Sauvegarder le graphique des résidus standardisés
ggsave("//Users/mehdifehri/Desktop/R/Données/Graphique_Residus_Standardises.png", plot = plot_residus)

# Étape 9 : Créer un tableau récapitulatif des outliers
# Ajout d'une colonne 'Reason' pour préciser la raison de la suppression (résidu trop élevé)
if (nrow(outliers_df) > 0) {
  recap_outliers <- outliers_df %>%
    mutate(Reason = paste("Résidu standardisé > ±", threshold))
} else {
  recap_outliers <- data.frame(Index = integer(),
                               Std_Resid = numeric(),
                               Reason = character(),
                               stringsAsFactors = FALSE)
}

# Étape 10 : Supprimer les outliers du DataFrame original
final_dataframe_no_outliers <- final_dataframe_lagged[-outliers_df$Index, ]

# Étape 11 : Sauvegarder les DataFrames et le tableau récapitulatif
write_xlsx(final_dataframe_no_outliers, "//Users/mehdifehri/Desktop/R/Données/Final_Data_No_Outliers.xlsx")
write_xlsx(recap_outliers, "//Users/mehdifehri/Desktop/R/Données/Recap_Outliers.xlsx")

# Étape 12 : Afficher des informations sur le nombre d'observations supprimées
initial_dim <- dim(final_dataframe_lagged)
final_dim <- dim(final_dataframe_no_outliers)
cat("Dimensions initiales :", initial_dim[1], "x", initial_dim[2], "\n")
cat("Dimensions finales (sans outliers) :", final_dim[1], "x", final_dim[2], "\n")
cat("Nombre d'observations supprimées :", initial_dim[1] - final_dim[1], "\n")


##############################################################
# DÉTECTION DES ALIAS (COLINÉARITÉS PARFAITES)
##############################################################

library(readxl)
library(writexl)

# Étape 1 : Charger le DataFrame sans outliers
final_dataframe_no_outliers <- read_excel("//Users/mehdifehri/Desktop/R/Données/Final_Data_No_Outliers.xlsx")

# Étape 2 : Identifier les variables explicatives
# On exclut 'fec' (variable dépendante) et 'Annee' (index temporel)
variables_explicatives <- setdiff(names(final_dataframe_no_outliers), c("fec", "Annee"))

# Étape 3 : Ajuster un modèle linéaire complet avec toutes les variables explicatives
full_model <- lm(fec ~ ., data = final_dataframe_no_outliers[, c("fec", variables_explicatives)])

# Étape 4 : Détecter les colinéarités parfaites avec la fonction alias()
alias_results <- alias(full_model)

# Étape 5 : Afficher les résultats d'alias
print(alias_results)

# Étape 6 : Déterminer les variables problématiques (colinéarité parfaite)
problematic_vars <- rownames(alias_results$Complete)

# Étape 7 : Si des variables problématiques sont détectées, les supprimer
if (length(problematic_vars) > 0) {
  final_dataframe_no_alias <- final_dataframe_no_outliers %>%
    select(-all_of(problematic_vars))
  
  # Étape 8 : Sauvegarder le nouveau DataFrame sans alias
  write_xlsx(final_dataframe_no_alias, "//Users/mehdifehri/Desktop/R/Données/Final_Data_No_Alias.xlsx")
  
  # Étape 9 : Sauvegarder la liste des variables problématiques
  problematic_vars_df <- data.frame(Variable = problematic_vars)
  write_xlsx(problematic_vars_df, "//Users/mehdifehri/Desktop/R/Données/Alias_Results.xlsx")
  
} else {
  cat("Aucune colinéarité parfaite détectée, aucune variable supprimée.\n")
}
